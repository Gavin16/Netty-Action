/**
 * @Package: multiThread.nioTest.netty.chatting
 * @Description: TODO
 * @author: Minsky
 * @date: 2019/7/13 14:33
 * @version: v1.0
 */
package netty.chatting;

/**
 *  实战设计一个聊天软件后台的实现,技术实现上的主要内容如下：
 *
 *
 *  (1)该场景的功能由于是在TCP 层实现,因此需要定义应用层的协议：
 *         协议定义如下：
 *        -------------------------------------------------------------------------------------
 *          协议标识        |  版本号  |   序列化算法   |  指令   |  数据长度    | 数据
 *        -------------------------------------------------------------------------------------
 *          0x12345678     |   1     |    1         |  1     |   100       |    ---
 *        -------------------------------------------------------------------------------------
 *              4 字节      |   1 字节|    1 字节     |  1字节  |   4 字节     | N字节(4字节表示范围内)
 *        -------------------------------------------------------------------------------------
 *
 *  协议相关的定义及工具类,统一放在 protocol 子路径下
 *
 *  (2) 登录之后以后的每次登录均不需要再做登录操作, 因此服务端需要保存用户的登录状态,登录状态的保存采用
 *          ServerBootStrap.childAttr() 方式
 *  (3) 聊天涉及到需要可以重复发送消息, 这里采用从控制台读取单行消息的方式获取输入
 *
 *  (4) 接收和发送消息的编解码，定义继承 ByteToMessageDecoder 和 MessageToByteEncoder 的子类,在子类中实现
 *      自定义协议的解码和编码，然后再通道的 pipline 中添加编解码器。 这样可以使自定义的handler 拿到接收数据时就能立刻使用，简化开发过程。
 *      相关的编解码器定义在  encoder 子路径下
 *
 *  (5) 登录之后可能需要传不同的指令， 不同的指令对应不同的处理逻辑，通过继承 SimpleChannelInboundHandler<T>  通过制定 T 的类型来区分不同的指令，
 *      这得以使 每个自定义的handler 都可以拿到指定类型的指令，然后在 channelRead方法中获取并执行想要的业务逻辑。
 *      相同类型的T 在前一个handler 执行完之后，会再传给后一个handler 直到调用channel 的 write 方法？？
 *
 *  (6) 虽然我们定义了自己的 ByteBuf 来发送数据, 但是由于操作系统发送的是二进制流, 因此ByteBuf 里面的数据可能会被拆分成两次TCP 报文或者 多个
 *      ByteBuf 合成个报文, 这就是常见的拆包和粘包的问题。
 *      Netty 提供了四种对TCP二进制流进行划分的方式：
 *      FixedLengthFrameDecoder         -- 基于固定长度的拆包器
 *      LineBasedFrameDecoder           -- 基于行拆包器
 *      DelimiterBasedFrameDecoder      -- 基于自定义分隔符拆包器
 *      LengthFieldBasedFrameDecoder    -- 基于长度域的拆包器
 *
 *      这里我们使用最常用的 基于长度域的拆包器
 *      使用方式也很简单, 需要需要在如下构造方法
 *      public LengthFieldBasedFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength)
 *      中指定 最大帧长度 -- maxFrameLength, 长度域相对于帧头的偏移量 -- lengthFieldOffset 和 长度域的长度(字节数) -- lengthFieldLength 即可。
 *      最后只需要在pipline 的最前面增加 该包拆分器，传输数据的拆包就会按实际发送的数据定义来拆分。
 *
 *  (7) 以上消息的发送都只是客户端与服务端，要实现聊天的功能还需将客户端发送给服务端的消息再发送给指定其它客户端。
 *      消息从一个客户端发给另一个客户端, 只需要让服务端保存目标客户端的 id --> channel 的映射关系即可，当服务端收到
 *      来自客户端的发送请求时，根据接收用户的id 取出 其对应的channel ，然后将发送消息写到channel 中即可。
 *
 *  (8) 当客户端或者服务端长期没有接收到请求或者响应时，则可以认为当前连接处于假死状态, 假死状态的连接有可能是因为信号中断,停机死机等各种原因造成了连接失效
 *      尤其是服务端的连接资源相对宝贵一些，因此需要对假死状态的连接进行清理。
 *      关闭假死的连接只需要  定义一个 继承自 IdleStateHandler 的处理器，然后覆写 channleIdle 方法，在该方法中处理假死的连接。
 *
 *
 *  (9) 上述判断假死连接的依据是超过多长时间没有收到消息，这种做法会把那些连接是有效的,但是由于确实没有消息需要发送，因此较长时间处于空闲状态  的连接关闭掉；
 *      为了让假死连接 和 有效空闲连接区分开。我们需要在客户端定时的向服务端发送一个心跳连接,服务端接收到心跳信息后可以也回复一个心跳信息给客户端,这样双发都能收到
 *      对方的消息，就可以判断双方之间的连接时有效的空闲连接。
 *      一般心跳间隔  < 1/2 假死判断时间间隔 ； 这样可以让因为网络拥塞导致的某次消息发送失败的情况 还有重试的机会。一定程度上减小建立连接的开销。
 *
 *
 */